using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;
using SeniorIS;

public class GenerateObjects : MonoBehaviour {
    public GameObject wrappedZone = null;
    public bool isWrapedZoneActive = false;
    public GameObject smallZone = null;
    public bool isSmallZoneActive = true;
    public List<float> sizeList = Metadata.sizeList;
    public float HeightMax = Metadata.HEIGHT_MAX;
    public int InteractiveCount = Metadata.INTERACTIVE_COUNT;
    public int NonInteractiveCount = Metadata.NONINTERACTIVE_COUNT;
    public bool generateSphere = true;
    public bool generateCube = true;
    public bool generateCylinder = true;
    public bool boyanceSimulate = false;
    static private bool DEBUG_MODE = false;
    private bool isModified = false;

    Vector3 RandomizeVector3(Vector3 min, Vector3 max) {
        float rand_x = Random.Range(min.x, max.x);
        float rand_y = Random.Range(min.y, max.y);
        float rand_z = Random.Range(min.z, max.z);
        return new Vector3(rand_x, rand_y, rand_z);
    }
    
    bool isBetween(float point, float point1, float point2) {
    // given two point without knowing which one is greater, see if point given is in between 
        bool result = (Math.Abs(point1 - point2) >= Math.Abs(point - point1) && Math.Abs(point1 - point2) >= Math.Abs(point - point2));
        if (DEBUG_MODE)
            Debug.Log("isBetween(point=" + point + ", point1=" + point1 + ", point2=" + point2 + ") returns " + result);
        
        return result; 
    }
    
    Vector3 RandomizeVector3Except(Vector3 smallRangeMin, Vector3 smallRangeMax, Vector3 bigRangeMin, Vector3 bigRangeMax) {
    // input two areas: small and big areas defined by their min max bounds
    // output a random vector3 that falls in the bigger area but not the smaller area
    // bigRange must wrap around than smallRange

        Vector3 randVector = RandomizeVector3(bigRangeMin, bigRangeMax);
        if (DEBUG_MODE)
            Debug.Log("RandomizeExcept: returns randVector " + randVector);
        if (isBetween(randVector.x, smallRangeMax.x, smallRangeMin.x)) {
            while (isBetween(randVector.z, smallRangeMin.z, smallRangeMax.z))
                randVector.z = Random.Range(bigRangeMin.z, bigRangeMax.z);
        }
        return randVector;    
    } 

    Vector3 getBoundMinOf(GameObject obj) {
        Renderer rend = obj.GetComponent<Renderer>();
        if (DEBUG_MODE)
            Debug.Log(obj + " has min bound: " + rend.bounds.min);
        return rend.bounds.min;
    }

    Vector3 getBoundMaxOf(GameObject obj) {
        Renderer rend = obj.GetComponent<Renderer>();
        if (DEBUG_MODE)
            Debug.Log(obj + " has max bound: " + rend.bounds.max);
        return rend.bounds.max;
    }

    void GenerateSphere(bool isInteractive, bool smallAreaOnly) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable sphere objs)

        List<List<GameObject>> spheresList = new List<List<GameObject>>();
        for (int i = 0; i < Metadata.sizeList.Count; i++) {
            spheresList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone

            string sObjPath;
            Vector3 minBorder, maxBorder;
            int count;
            if (isInteractive) {
                count = InteractiveCount;
                sObjPath = Metadata.PATH_TO_ASSET_INTERACTIVE;
            }
            else {
                count = NonInteractiveCount;
                sObjPath = Metadata.PATH_TO_ASSET_NONINTERACTIVE;
            }

            if (smallAreaOnly) {
                minBorder = getBoundMinOf(smallZone);
                maxBorder = getBoundMaxOf(smallZone);
            }
            else {
                minBorder = getBoundMinOf(wrappedZone);
                maxBorder = getBoundMaxOf(wrappedZone);
            }


            for (int sphereObjCounter = 0; sphereObjCounter < count; sphereObjCounter++) {
                // create the primitive shape
                spheresList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Sphere));
                GameObject current = spheresList[i][sphereObjCounter];

                // Randomize position
                Vector3 tempVec;
                if (smallAreaOnly)
                    tempVec = RandomizeVector3(minBorder, maxBorder);
                else
                    tempVec = RandomizeVector3Except(getBoundMinOf(smallZone), getBoundMaxOf(smallZone), minBorder, maxBorder);

                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(transform.position.y, transform.position.y+HeightMax), tempVec.z);

                if (DEBUG_MODE)
                    if (!isInteractive) Debug.Log("Position of NonInteractive Object: " + newPosition);

                // Transform
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }

            foreach (GameObject sphere in spheresList[i]) {
                // Add Display Script to the Scriptable object
                SphereDisplay displayScript = sphere.AddComponent<SphereDisplay>() as SphereDisplay;
                displayScript.sphere = (Sphere)AssetDatabase.LoadAssetAtPath(sObjPath + "Sphere " + Metadata.sizeList[i] + ".asset", typeof(Sphere));


                // Add Floating script if boyanceSimulate is true
                if (boyanceSimulate)
                    sphere.AddComponent<ObjectFloat>();
            }

        }
    }

    void GenerateCube(bool isInteractive, bool smallAreaOnly) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cube objs)

        List<List<GameObject>> cubesList = new List<List<GameObject>>();
        for (int i = 0; i < Metadata.sizeList.Count; i++) {
            cubesList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone

            string sObjPath;
            Vector3 minBorder, maxBorder;
            int count;
            if (isInteractive) {
                count = InteractiveCount;
                sObjPath = Metadata.PATH_TO_ASSET_INTERACTIVE;
            }
            else {
                count = NonInteractiveCount;
                sObjPath = Metadata.PATH_TO_ASSET_NONINTERACTIVE;
            }

            if (smallAreaOnly) {
                minBorder = getBoundMinOf(smallZone);
                maxBorder = getBoundMaxOf(smallZone);
            }
            else {
                minBorder = getBoundMinOf(wrappedZone);
                maxBorder = getBoundMaxOf(wrappedZone);
            }


            for (int cubeObjCounter = 0; cubeObjCounter < count; cubeObjCounter++) {
                // create the primitive shape
                cubesList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Cube));
                GameObject current = cubesList[i][cubeObjCounter];

                // Randomize position
                Vector3 tempVec;
                if (smallAreaOnly)
                    tempVec = RandomizeVector3(minBorder, maxBorder);
                else
                    tempVec = RandomizeVector3Except(getBoundMinOf(smallZone), getBoundMaxOf(smallZone), minBorder, maxBorder);

                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(transform.position.y, transform.position.y+HeightMax), tempVec.z);

                if (DEBUG_MODE)
                    if (!isInteractive) Debug.Log("Position of NonInteractive Object: " + newPosition);

                // Transform
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }

            foreach (GameObject cube in cubesList[i]) {
                // Add Display Script to the Scriptable object
                CubeDisplay displayScript = cube.AddComponent<CubeDisplay>() as CubeDisplay;
                displayScript.cube = (Cube)AssetDatabase.LoadAssetAtPath(sObjPath + "Cube " + Metadata.sizeList[i] + ".asset", typeof(Cube));

                // Add Floating script if boyanceSimulate is true
                if (boyanceSimulate)
                    cube.AddComponent<ObjectFloat>();

            }

        }
    }

    void GenerateCylinder(bool isInteractive, bool smallAreaOnly) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cylinder objs)

        List<List<GameObject>> cylindersList = new List<List<GameObject>>();
        for (int i = 0; i < Metadata.sizeList.Count; i++) {
            cylindersList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone

            string sObjPath;
            Vector3 minBorder, maxBorder;
            int count;
            if (isInteractive) {
                count = InteractiveCount;
                sObjPath = Metadata.PATH_TO_ASSET_INTERACTIVE;
            }
            else {
                count = NonInteractiveCount;
                sObjPath = Metadata.PATH_TO_ASSET_NONINTERACTIVE;
            }

            if (smallAreaOnly) {
                minBorder = getBoundMinOf(smallZone);
                maxBorder = getBoundMaxOf(smallZone);
            }
            else {
                minBorder = getBoundMinOf(wrappedZone);
                maxBorder = getBoundMaxOf(wrappedZone);
            }


            for (int cylinderObjCounter = 0; cylinderObjCounter < count; cylinderObjCounter++) {
                // Create the primitive shape
                cylindersList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Cylinder));
                GameObject current = cylindersList[i][cylinderObjCounter];

                // Randomize position Vector3
                Vector3 tempVec;
                if (smallAreaOnly)
                    tempVec = RandomizeVector3(minBorder, maxBorder);
                else
                    tempVec = RandomizeVector3Except(getBoundMinOf(smallZone), getBoundMaxOf(smallZone), minBorder, maxBorder);

                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(transform.position.y, transform.position.y+HeightMax), tempVec.z);

                if (DEBUG_MODE)
                    Debug.Log("Position in world space of y vertex: " + transform.position.y);

                if (DEBUG_MODE)
                    if (! isInteractive) Debug.Log("Position of NonInteractive Object: " + newPosition);
                
                // Transform random position & rotation
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }

            foreach (GameObject cylinder in cylindersList[i]) {
                // Add Display Script to the Scriptable object
                CylinderDisplay displayScript = cylinder.AddComponent<CylinderDisplay>() as CylinderDisplay;
                displayScript.cylinder = (Cylinder)AssetDatabase.LoadAssetAtPath(sObjPath + "Cylinder " + Metadata.sizeList[i] + ".asset", typeof(Cylinder));

                // Add Floating script if boyanceSimulate is true
                if (boyanceSimulate)
                    cylinder.AddComponent<ObjectFloat>();
            }

        }
    }

    public enum Trash {
        sphere,
        cube,
        cylinder
    }


    public void generateMore(Trash input, bool isInteractive) {    
        if (input == Trash.sphere)
            GenerateSphere(isInteractive = isSmallZoneActive, true);
        else if (input == Trash.cube)
            GenerateCube(isInteractive = isSmallZoneActive, true);
        else if (input == Trash.cylinder)
            GenerateCylinder(isInteractive = isSmallZoneActive, true);
    }
    

    void Start() {
        bool isInteractive;
        // Caution: Should only use this to generate the asset at the beginning, never at run-time!!  
        // Because the assets will be overrided if there are multiple Generate Object scripts on the scene
        // leads to run-time error
        //
        //CreateScriptableObjects.CreateAsset(sizeList, isInteractive = true);
        //CreateScriptableObjects.CreateAsset(sizeList, isInteractive = false);

        if (wrappedZone != null) {
            if (generateCube) GenerateCube(isInteractive = isWrapedZoneActive, (wrappedZone == null));
            if (generateSphere) GenerateSphere(isInteractive = isWrapedZoneActive, (wrappedZone == null));
            if (generateCylinder) GenerateCylinder(isInteractive = isWrapedZoneActive, (wrappedZone == null));
        }

        if (smallZone != null) {
            if (generateCube) GenerateCube(isInteractive = isSmallZoneActive, (wrappedZone == null));
            if (generateSphere) GenerateSphere(isInteractive = isSmallZoneActive, (wrappedZone == null));
            if (generateCylinder) GenerateCylinder(isInteractive = isSmallZoneActive, (wrappedZone == null));
        }
    }

    private int counter = 0;

    private void Update() {
        if (Random.Range(-1f, 1f) > 0) {
            if (counter < 10) {
                Debug.Log("counter: " + counter);
                //if (counter % 3 == 0) generateMore(Trash.cylinder, false);
                //else if (counter % 3 == 1) generateMore(Trash.cube, false);
                //else if (counter % 3 == 2) generateMore(Trash.sphere, false);
                counter++;
                generateMore(Trash.cube, false);
            }
        }
    }

}