using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

public class GenerateObjects : MonoBehaviour {
    public GameObject ground;
    public GameObject groundActiveZone;

    static string PATH_TO_ASSET = "Assets/Mine/";
    static string PATH_TO_ASSET_INTERACTIVE = PATH_TO_ASSET + "Prefab-Interactive/";
    static string PATH_TO_ASSET_NONINTERACTIVE = PATH_TO_ASSET + "Prefab-NonInteractive/";
    static int INTERACTIVE_COUNT = 30;
    static int NONINTERACTIVE_COUNT = 20;
    static List <float> sizeList = new List<float>() { .05f, .11f, .07f };

    Vector3 RandomizeVector3(Vector3 min, Vector3 max) {
        float rand_x = Random.Range(min.x, max.x);
        float rand_y = Random.Range(min.y, max.y);
        float rand_z = Random.Range(min.z, max.z);
        return new Vector3(rand_x, rand_y, rand_z);
    }
    
    Vector3 RandomizeVector3Except(Vector3 smallRangeMin, Vector3 smallRangeMax, Vector3 bigRangeMin, Vector3 bigRangeMax) {
        // inRange must wrap around than outRange
        Vector3 positioninSmallArea = RandomizeVector3(smallRangeMin, smallRangeMax);
        
        // random 1/2
        if (Random.value > .5f) {
            // case +
            return positioninSmallArea + (bigRangeMin - smallRangeMin);
        }
        else {
            // case -
            return positioninSmallArea + (bigRangeMax - smallRangeMax);
        }
        
    } 

    Vector3 getBoundMinOf(GameObject obj) {
        Renderer rend = obj.GetComponent<Renderer>();
        return rend.bounds.min;
    }

    Vector3 getBoundMaxOf(GameObject obj) {
        Renderer rend = obj.GetComponent<Renderer>();
        return rend.bounds.max;
    }

    void GenerateSphere(bool isInteractive) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cube objs)

        List<List<GameObject>> spheresList = new List<List<GameObject>>();
        for (int i = 0; i < sizeList.Count; i++) {
            spheresList.Add(new List<GameObject>());
            for (int sphereObjCounter = 0; sphereObjCounter < INTERACTIVE_COUNT; sphereObjCounter++) {
                spheresList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Sphere));
            }
            
            // if Obj is interactive then load asset from interactive else non-interactive
            string sObjPath = PATH_TO_ASSET_NONINTERACTIVE;
            if (isInteractive)
                sObjPath = PATH_TO_ASSET_INTERACTIVE;

            foreach (GameObject sphere in spheresList[i]) {
                SphereDisplay displayScript = sphere.AddComponent<SphereDisplay>() as SphereDisplay;
                displayScript.sphere = (Sphere)AssetDatabase.LoadAssetAtPath(sObjPath + "Sphere " + sizeList[i] + ".asset", typeof(Sphere));
            }
        }
    }

    void GenerateCube(bool isInteractive) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cube objs)

        List<List<GameObject>> cubesList = new List<List<GameObject>>();
        for (int i = 0; i < sizeList.Count; i++) {
            cubesList.Add(new List<GameObject>());
            for (int cubeObjCounter = 0; cubeObjCounter < INTERACTIVE_COUNT; cubeObjCounter++) {
                cubesList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Cube));
            }

            // if Obj is interactive then load asset from interactive else non-interactive
            string sObjPath = PATH_TO_ASSET_NONINTERACTIVE;
            if (isInteractive)
                sObjPath = PATH_TO_ASSET_INTERACTIVE;

            foreach (GameObject cube in cubesList[i]) {
                CubeDisplay displayScript = cube.AddComponent<CubeDisplay>() as CubeDisplay;
                displayScript.cube = (Cube)AssetDatabase.LoadAssetAtPath(sObjPath + "Cube " + sizeList[i] + ".asset", typeof(Cube));
            }

        }
    }

    void GenerateCylinder(bool isInteractive) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cylinder objs)

        List<List<GameObject>> cylindersList = new List<List<GameObject>>();
        for (int i = 0; i < sizeList.Count; i++) {
            cylindersList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone
            string sObjPath = PATH_TO_ASSET_NONINTERACTIVE;
            Vector3 minBorder = getBoundMinOf(ground);
            Vector3 maxBorder = getBoundMinOf(ground);
            Vector3 tempVec = RandomizeVector3Except(getBoundMinOf(groundActiveZone), getBoundMaxOf(groundActiveZone), minBorder, maxBorder);

            if (isInteractive) {
                sObjPath = PATH_TO_ASSET_INTERACTIVE;
                minBorder = getBoundMinOf(groundActiveZone);
                maxBorder = getBoundMaxOf(groundActiveZone);
                tempVec = RandomizeVector3(minBorder, maxBorder);
            }

            for (int cylinderObjCounter = 0; cylinderObjCounter < INTERACTIVE_COUNT; cylinderObjCounter++) {
                // create the primitive shape
                cylindersList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Cylinder));
                GameObject current = cylindersList[i][cylinderObjCounter];

                // Randomize position
                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(tempVec.y + 5, 30f), tempVec.z);

                // Transform
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }
        
            foreach (GameObject cylinder in cylindersList[i]) {
                CylinderDisplay displayScript = cylinder.AddComponent<CylinderDisplay>() as CylinderDisplay;
                displayScript.cylinder = (Cylinder)AssetDatabase.LoadAssetAtPath(sObjPath + "Cylinder " + sizeList[i] + ".asset", typeof(Cylinder));
            }

        }
    }

    void Start() {
        Renderer rend = groundActiveZone.GetComponent<Renderer>();
        Debug.Log(rend.bounds.max);
        Debug.Log(rend.bounds.min);
        bool isInteractive = true;

        CreateScriptableObjects.CreateAsset(sizeList, isInteractive=true);
        CreateScriptableObjects.CreateAsset(sizeList, isInteractive = false);
        //GenerateSphere(isInteractive=true);
        //GenerateCube(isInteractive = true);
        GenerateCylinder(isInteractive=true);
        GenerateCylinder(isInteractive = false);
    }
    
}