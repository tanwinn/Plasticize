using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;
using SeniorIS;

public class GenerateObjects : MonoBehaviour {
    public GameObject ground;
    public GameObject groundActiveZone;

    static private bool DEBUG_MODE = false;

    Vector3 RandomizeVector3(Vector3 min, Vector3 max) {
        float rand_x = Random.Range(min.x, max.x-.26f);
        float rand_y = Random.Range(min.y, max.y-.22f);
        float rand_z = Random.Range(min.z, max.z-.27f);
        return new Vector3(rand_x, rand_y, rand_z);
    }
    
    bool isBetween(float point, float point1, float point2) {
    // given two point without knowing which one is greater, see if point given is in between 
        bool result = (Math.Abs(point1 - point2) >= Math.Abs(point - point1) && Math.Abs(point1 - point2) >= Math.Abs(point - point2));
        if (DEBUG_MODE)
            Debug.Log("isBetween(point=" + point + ", point1=" + point1 + ", point2=" + point2 + ") returns " + result);
        
        return result; 
    }
    
    Vector3 RandomizeVector3Except(Vector3 smallRangeMin, Vector3 smallRangeMax, Vector3 bigRangeMin, Vector3 bigRangeMax) {
    // input two areas: small and big areas defined by their min max bounds
    // output a random vector3 that falls in the bigger area but not the smaller area
    // bigRange must wrap around than smallRange

        Vector3 randVector = RandomizeVector3(bigRangeMin, bigRangeMax);
        if (DEBUG_MODE)
            Debug.Log("RandomizeExcept: returns randVector " + randVector);
        if (isBetween(randVector.x, smallRangeMax.x, smallRangeMin.x)) {
            while (isBetween(randVector.z, smallRangeMin.z, smallRangeMax.z))
                randVector.z = Random.Range(bigRangeMin.z, bigRangeMax.z);
        }
        return randVector;    
    } 

    Vector3 getBoundMinOf(GameObject obj) {
        Renderer rend = obj.GetComponent<Renderer>();
        if (DEBUG_MODE)
            Debug.Log(obj + " has min bound: " + rend.bounds.min);
        return rend.bounds.min;
    }

    Vector3 getBoundMaxOf(GameObject obj) {
        Renderer rend = obj.GetComponent<Renderer>();
        if (DEBUG_MODE)
            Debug.Log(obj + " has max bound: " + rend.bounds.max);
        return rend.bounds.max;
    }

    void GenerateSphere(bool isInteractive) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable sphere objs)

        List<List<GameObject>> spheresList = new List<List<GameObject>>();
        for (int i = 0; i < Metadata.sizeList.Count; i++) {
            spheresList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone

            string sObjPath;
            Vector3 minBorder, maxBorder;
            int count;
            if (isInteractive) {
                count = Metadata.INTERACTIVE_COUNT;
                sObjPath = Metadata.PATH_TO_ASSET_INTERACTIVE;
                minBorder = getBoundMinOf(groundActiveZone);
                maxBorder = getBoundMaxOf(groundActiveZone);
            }
            else {
                count = Metadata.NONINTERACTIVE_COUNT;
                sObjPath = Metadata.PATH_TO_ASSET_NONINTERACTIVE;
                minBorder = getBoundMinOf(ground);
                maxBorder = getBoundMaxOf(ground);
            }


            for (int sphereObjCounter = 0; sphereObjCounter < count; sphereObjCounter++) {
                // create the primitive shape
                spheresList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Sphere));
                GameObject current = spheresList[i][sphereObjCounter];

                // Randomize position
                Vector3 tempVec;
                if (isInteractive)
                    tempVec = RandomizeVector3(minBorder, maxBorder);
                else
                    tempVec = RandomizeVector3Except(getBoundMinOf(groundActiveZone), getBoundMaxOf(groundActiveZone), minBorder, maxBorder);

                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(tempVec.y + 5, Metadata.HEIGHT_MAX), tempVec.z);

                if (DEBUG_MODE)
                    if (!isInteractive) Debug.Log("Position of NonInteractive Object: " + newPosition);

                // Transform
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }

            // Add Display Script to the Scriptable object
            foreach (GameObject sphere in spheresList[i]) {
                SphereDisplay displayScript = sphere.AddComponent<SphereDisplay>() as SphereDisplay;
                displayScript.sphere = (Sphere)AssetDatabase.LoadAssetAtPath(sObjPath + "Sphere " + Metadata.sizeList[i] + ".asset", typeof(Sphere));
            }

        }
    }

    void GenerateCube(bool isInteractive) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cube objs)

        List<List<GameObject>> cubesList = new List<List<GameObject>>();
        for (int i = 0; i < Metadata.sizeList.Count; i++) {
            cubesList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone

            string sObjPath;
            Vector3 minBorder, maxBorder;
            int count;
            if (isInteractive) {
                count = Metadata.INTERACTIVE_COUNT;
                sObjPath = Metadata.PATH_TO_ASSET_INTERACTIVE;
                minBorder = getBoundMinOf(groundActiveZone);
                maxBorder = getBoundMaxOf(groundActiveZone);
            }
            else {
                count = Metadata.NONINTERACTIVE_COUNT;
                sObjPath = Metadata.PATH_TO_ASSET_NONINTERACTIVE;
                minBorder = getBoundMinOf(ground);
                maxBorder = getBoundMaxOf(ground);
            }


            for (int cubeObjCounter = 0; cubeObjCounter < count; cubeObjCounter++) {
                // create the primitive shape
                cubesList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Cube));
                GameObject current = cubesList[i][cubeObjCounter];

                // Randomize position
                Vector3 tempVec;
                if (isInteractive)
                    tempVec = RandomizeVector3(minBorder, maxBorder);
                else
                    tempVec = RandomizeVector3Except(getBoundMinOf(groundActiveZone), getBoundMaxOf(groundActiveZone), minBorder, maxBorder);

                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(tempVec.y + 5, Metadata.HEIGHT_MAX), tempVec.z);

                if (DEBUG_MODE)
                    if (!isInteractive) Debug.Log("Position of NonInteractive Object: " + newPosition);

                // Transform
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }

            // Add Display Script to the Scriptable object
            foreach (GameObject cube in cubesList[i]) {
                CubeDisplay displayScript = cube.AddComponent<CubeDisplay>() as CubeDisplay;
                displayScript.cube = (Cube)AssetDatabase.LoadAssetAtPath(sObjPath + "Cube " + Metadata.sizeList[i] + ".asset", typeof(Cube));
            }

        }
    }

    void GenerateCylinder(bool isInteractive) {
        // List<gObj> is the number of prefabs generated by ONE scriptable Objects
        // List<List<>> is list of scriptable objects (e.g. all the scriptable cylinder objs)

        List<List<GameObject>> cylindersList = new List<List<GameObject>>();
        for (int i = 0; i < Metadata.sizeList.Count; i++) {
            cylindersList.Add(new List<GameObject>());

            // if Obj is interactive then load asset from interactive folder else non-interactive
            // interactive objs are in active zone else outside of active zone

            string sObjPath;
            Vector3 minBorder, maxBorder;
            int count;
            if (isInteractive) {
                count = Metadata.INTERACTIVE_COUNT;
                sObjPath = Metadata.PATH_TO_ASSET_INTERACTIVE;
                minBorder = getBoundMinOf(groundActiveZone);
                maxBorder = getBoundMaxOf(groundActiveZone);
            }
            else {
                count = Metadata.NONINTERACTIVE_COUNT;
                sObjPath = Metadata.PATH_TO_ASSET_NONINTERACTIVE;
                minBorder = getBoundMinOf(ground);
                maxBorder = getBoundMaxOf(ground);
            }


            for (int cylinderObjCounter = 0; cylinderObjCounter < count; cylinderObjCounter++) {
                // Create the primitive shape
                cylindersList[i].Add(GameObject.CreatePrimitive(PrimitiveType.Cylinder));
                GameObject current = cylindersList[i][cylinderObjCounter];

                // Randomize position Vector3
                Vector3 tempVec;
                if (isInteractive)
                    tempVec = RandomizeVector3(minBorder, maxBorder);
                else
                    tempVec = RandomizeVector3Except(getBoundMinOf(groundActiveZone), getBoundMaxOf(groundActiveZone), minBorder, maxBorder);

                Vector3 newPosition = new Vector3(tempVec.x, Random.Range(tempVec.y + 5, Metadata.HEIGHT_MAX), tempVec.z);

                if (DEBUG_MODE)
                    if (! isInteractive) Debug.Log("Position of NonInteractive Object: " + newPosition);
                
                // Transform random position & rotation
                current.transform.position = newPosition;
                current.transform.rotation = Random.rotationUniform;
            }

            // Add Display Script to the Scriptable object
            foreach (GameObject cylinder in cylindersList[i]) {
                CylinderDisplay displayScript = cylinder.AddComponent<CylinderDisplay>() as CylinderDisplay;
                displayScript.cylinder = (Cylinder)AssetDatabase.LoadAssetAtPath(sObjPath + "Cylinder " + Metadata.sizeList[i] + ".asset", typeof(Cylinder));
            }

        }
    }

    void Start() {
        bool isInteractive = true;
        CreateScriptableObjects.CreateAsset(Metadata.sizeList, isInteractive=true);
        CreateScriptableObjects.CreateAsset(Metadata.sizeList, isInteractive = false);
        GenerateSphere(isInteractive=false);
        GenerateSphere(isInteractive = true);
        GenerateCube(isInteractive = true);
        GenerateCube(isInteractive = false);
        GenerateCylinder(isInteractive=true);
        GenerateCylinder(isInteractive = false);
        //LeapMotionControllerCrossPlatform test = new LeapMotionControllerCrossPlatform();
        //GameObject test = new GameObject();
        //test.AddComponent<LeapMotionControllerCrossPlatform>();
    }
    
}